/* Copyright (c) 2019-2021 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2021 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .util;
import fs;
import util;


global final CP_CLASS_8      = 0;
global final CP_CLASS_7L     = 1;
global final CP_CLASS_7H     = 2;
global final CP_CLASS_ISO646 = 3;

global final ISO646_OVERRIDE_ORDINALS = {
	0x21, 0x22, 0x23, 0x24, 0x26, 0x3a, 0x3f, 0x40, 0x5b,
	0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d, 0x7e
};

class CodecAlias {
	this = default;
	public member ppCond: string = "1";
	public member name: string;
}

class Codec {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];
}

class CodePage {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];
	public member table: {int...} = List([0] * 256);

	@@Returns one of `CP_CLASS_*`
	public function getCpClass(): int {
		if (table[:128] == [:128])
			return CP_CLASS_7H;
		if (!(table[128:256] + ...)) {
			/* Check for ISO646 */
			local iso646_table = List([:128]);
			for (local i: ISO646_OVERRIDE_ORDINALS)
				iso646_table[i] = table[i];
			if (iso646_table == table[:128])
				return CP_CLASS_ISO646;
			return CP_CLASS_7L;
		}
		return CP_CLASS_8;
	}
}

class StatefulCodec {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];

	@@Single-byte table
	public member sb_table: {int...} = List([0] * 256);

	@@Double-byte table
	public member db_table: {int: int | {int...}} = Dict();
}


@@Multi-byte codec (each character is 1- or 2 bytes).
class MbcsCodec {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];

	@@Decode  map. Maps CP_ORD -> UNI_ORD or another
	@@table that is used to decode a second byte, or
	@@points to a third table, and so on.
	public member map: {int: int | {int: int | Object}} = Dict();
}



function getEncodeTable(table: {int...}, shift: int): {int: int} {
	local result = Dict();
	for (local encoded, decoded: util.enumerate(table))
		result.setdefault(decoded, encoded + shift);
	return result;
}

function dbFieldName(name: string): string {
	if (name.startswith("CODEC_"))
		return "db_" + name[6:];
	return "db_" + name;
}


function parseCodecAlias(s: string): CodecAlias {
	local ppCond = "1";
	s = s.strip();
	if (s.startswith("[")) {
		s = s[1:].lstrip();
		if (!s.startswith("if"))
			throw Error("Expected 'if' after '['");
		s = s[2:].lstrip();
		if (!s.startswith("("))
			throw Error("Expected '(' after '[if'");
		s = s[1:].lstrip();
		local condEnd = s.findmatch("(", ")");
		if (condEnd < 0)
			throw Error("Missing ')' after '[if('");
		ppCond = s[:condEnd].strip();
		s = s[condEnd+1:].lstrip();
		if (!s.startswith("]"))
			throw Error("Expected ']' after '[if(...)'");
		s = s[1:].lstrip();
	}
	return CodecAlias(ppCond: ppCond, name:
		normalizeCodecName(s.decode("c-escape")));
}

function constructCodecObject(typ: Type, arg: string): Object {
	local name, none, aliases = arg.partition(":")...;
	return typ(name: name, aliases: Tuple(
		for (local x: aliases.split(","))
			parseCodecAlias(x)));
}


function parseDBFilename(filename: string): {string: Object} {
	print File.stderr: "Loading database:", repr filename;
	local result = Dict();
	local data = File.open(filename, "r").read().decode("utf-8");
	local newData = File.Writer();
	function errAt(i: int, msg: string) {
		local sol = data.rfind("\n", 0, i) + 1;
		local line = data.count("\n", 0, sol) + 1;
		local col = 1 + (i - sol);
		print(filename, "(", line, ",", col, ") : ", msg);
		throw Error(msg);
	}
	local currentItem = none;
	local currentIndex = none;
	local currentTable = none;
	local usedNames = HashSet();
	local i = 0, len = #data, flushStart = 0;
	while (i < len) {
		local ch = data[i];
		if (ch.isspace()) {
			++i;
			continue;
		}
		if (ch == "#") {
			i = data.find("\n", i);
			if (i < 0)
				i = len;
			else {
				++i;
			}
			continue;
		}
		if (ch == "@") {
			++i;
			if (i >= len || !data.issymstrt(i))
				errAt(i, "Expected keyword after '@'");
			local kwdStart = i;
			++i;
			while (i < len && data.issymcont(i))
				++i;
			local kwd = data[kwdStart:i];
			while (i < len && data.isspace(i))
				++i;
			local arg = none;
			local argStart = none;
			if (i < len && data[i] == "(") {
				argStart = i + 1;
				local argEnd = data.findmatch("(", ")", argStart);
				if (argEnd < 0)
					errAt(i, "Unmatched '('");
				arg = data[argStart:argEnd];
				i = argEnd + 1;
			}
			function constructCurrentItem(typ: Type): Object {
				local obj = constructCodecObject(typ, arg);
				if (obj.name in result)
					errAt(argStart, "Codec " + obj.name + " already defined");
				result[obj.name] = obj;
				for (local a: obj.aliases) {
					if (a.ppCond != "1")
						continue;
					local lower_a = a.name.lower();
					if (lower_a in usedNames)
						errAt(argStart, "Alias " + a.name + " already defined");
					usedNames.insert(lower_a);
				}
				return obj;
			}

			switch (kwd.lower()) {

			case "include": {
				local argFilename = arg.decode("c-escape").replace("\\", "/");
				while (argFilename.startswith("./"))
					argFilename = argFilename[2:];
				local otherFilename = fs.joinpath(fs.headof(filename), argFilename);
				result.update(parseDBFilename(otherFilename));
			}	break;

			case "codec":
				currentItem  = constructCurrentItem(Codec);
				currentIndex = 0;
				currentTable = none;
				break;

			case "cp":
				currentItem  = constructCurrentItem(CodePage);
				currentIndex = 0;
				currentTable = currentItem.table;
				break;

			case "codec_stateful":
				currentItem  = constructCurrentItem(StatefulCodec);
				currentIndex = 0;
				currentTable = none;
				break;

			case "codec_mbcs":
				currentItem  = constructCurrentItem(MbcsCodec);
				currentIndex = 0;
				currentTable = none;
				break;

			case "sb":
				if (currentItem is MbcsCodec) {
					currentIndex = 0;
					currentTable = currentItem.map;
				} else if (currentItem is StatefulCodec) {
					currentIndex = 0;
					currentTable = currentItem.sb_table;
				} else {
					errAt(argStart, "@SB is only allowed for @CODEC_STATEFUL or @CODEC_MBCS");
				}
				break;

			case "db":
				if (currentItem is MbcsCodec) {
					local firstByte = arg, startOrd = "0";
					if ("," in arg) {
						firstByte, none, startOrd = arg.rpartition(",")...;
					}
					if (firstByte.startswith("[") && firstByte.endswith("]")) {
						firstByte = Tuple(
							for (local x: firstByte[1:-1].split(","))
								int(x.strip()));
					} else {
						firstByte = int(firstByte.strip());
					}
					currentIndex = int(startOrd.strip());
					if (firstByte is int) {
						currentTable = Dict();
						currentItem.map[firstByte] = currentTable;
					} else {
						currentTable = currentItem.map;
						for (local b: firstByte) {
							local newTab = currentTable.get(b);
							if (newTab !is Dict)
								currentTable[b] = newTab = Dict();
							currentTable = newTab;
						}
					}
				} else if (currentItem is StatefulCodec) {
					currentIndex = 0;
					currentTable = currentItem.db_table;
				} else {
					errAt(argStart, "@DB is only allowed for @CODEC_STATEFUL or @CODEC_MBCS");
				}
				break;

			case "ord": {
				local oldIndex = currentIndex;
				try {
					currentIndex = int(arg);
				} catch (...) {
					errAt(argStart, "Expected integer for @ord, but got " + repr arg);
				}
				if (currentItem is CodePage && oldIndex == 0) {
					for (local i: [oldIndex:currentIndex]) {
						if (currentItem.table[i] == 0)
							currentItem.table[i] = i;
					}
				}
			}	break;

			default:
				errAt(kwdStart, "Unknown command: " + repr kwd);
			}
			continue;
		}
		if (ch.isalnum()) {
			if (currentTable is none)
				errAt(i, "Unable to define ordinals at this time");
			if (currentTable is List || currentItem is MbcsCodec) {
				local lineIds = [];
				local lineStart = i;
				for (;;) {
					local uniStart = i;
					++i;
					while (i < len && data.isalnum(i))
						++i;
					local uni;
					local istr = data[uniStart:i].lower();
					if (istr.startswith("0x"))
						istr = istr[2:];
					try {
						uni = int("0x" + istr);
					} catch (...) {
						errAt(uniStart, "Invalid hex integer: " + repr data[uniStart:i]);
					}
					lineIds.append(uni);
					if (currentIndex >= 256)
						errAt(uniStart, "Character index out-of-bounds");
					currentTable[currentIndex] = uni;
					++currentIndex;
					while (i < len && data.isspace(i) && !data.islf(i))
						++i;
					if (i < len && data[i] == ",") {
						do {
							++i;
						} while (i < len && data.isspace(i) && !data.islf(i));
					}
					if (i >= len || !data.isalnum(i))
						break;
				}
				if (i >= len || data[i] in "#\n") {
					while (i > 0 && data.isspace(i - 1) && !data.islf(i - 1))
						--i;
					i = data.find("\n", i);
					if (i < 0)
						i = len;
					newData << data[flushStart:lineStart];
					for (local uni: lineIds)
						newData << uni.hex()[2:].upper().zfill(4) << " ";
					newData << "  # "
						<< (currentIndex - #lineIds).hex()[2:].upper().zfill(2)
						<< "-" << (currentIndex - 1).hex()[2:].upper().zfill(2)
						<< "  ";
					for (local uni: lineIds)
						newData << " " << uniEscape(uni);
					newData << " #";
					flushStart = i;
				}
				continue;
			} else if (currentTable is Dict) {
				/* Supported:
				 *   - ABCD    = 1234       // Single code-point
				 *   - ABCD+FF = 1234       // Map 255 consecutive points from ABCD to 1234+0, +1, +2, ...
				 *   - ABCD    = 1234,1235  // Map code point to a sequence of unicode characters */
				local ordStart = i;
				do {
					++i;
				} while (i < len && data.isalnum(i));
				local cp_ord, count = 1;
				try {
					cp_ord = int("0x" + data[ordStart:i]);
				} catch (...) {
					errAt(ordStart, "Invalid hex integer: " + repr data[ordStart:i]);
				}
				while (i < len && data.isspace(i))
					++i;
				if (i < len && data[i] == "+") {
					do {
						++i;
					} while (i < len && data.isspace(i));
					if (i >= len || !data.isalnum(i))
						errAt(i, "Expected digit after 'ABCD+'");
					local countStart = i;
					do {
						++i;
					} while (i < len && data.isalnum(i));
					try {
						count = int("0x" + data[countStart:i]);
					} catch (...) {
						errAt(countStart, "Invalid hex integer: " + repr data[countStart:i]);
					}
					while (i < len && data.isspace(i))
						++i;
				}
				if (i >= len || data[i] != "=")
					errAt(i, "Expected '=' after 'ABCD[+123]'");
				do {
					++i;
				} while (i < len && data.isspace(i));
				if (i >= len || !data.isalnum(i))
					errAt(i, "Expected digit after 'ABCD[+123]='");
				local uniOrds = [];
				for (;;) {
					local uniStart = i;
					do {
						++i;
					} while (i < len && data.isalnum(i));
					try {
						uniOrds.append(int("0x" + data[uniStart:i]));
					} catch (...) {
						errAt(uniStart, "Invalid hex integer: " + repr data[uniStart:i]);
					}
					while (i < len && data.isspace(i))
						++i;
					if (i >= len || data[i] != ",")
						break;
					do {
						++i;
					} while (i < len && data.isspace(i));
					if (i >= len || !data.isalnum(i))
						errAt(i, "Expected digit after 'ABCD=6789,'");
				}
				if (#uniOrds <= 1)
					uniOrds = uniOrds.first;
				else {
					uniOrds = Tuple(uniOrds);
				}
				if (count == 1) {
					currentTable[cp_ord] = uniOrds;
				} else {
					if (uniOrds !is int)
						errAt(ordStart, "Cannot encode multiple unicode characters range mappings");
					for (local offset: [:count])
						currentTable[cp_ord + offset] = uniOrds + offset;
				}
				continue;
			}
			errAt(i, "Unsupported type of currentTable: " + str(type(currentTable)));
			continue;
		}
		errAt(i, "Unexpected character: " + repr ch);
	}
	newData << data[flushStart:];
	newData = newData.string;
	if (newData != data) {
		newData = newData.encode("utf-8");
		with (local fp = File.open(filename, "w"))
			fp.write(newData);
	}

	local byTable = Dict();
	for (local none, tab: result) {
		if (tab is CodePage) {
			tab.table = Tuple(tab.table);
			if (tab.table == [:256])
				throw Error("Codec " + repr tab.name + " is just latin-1");
			if (tab.table == ([:128] + {0} * 128))
				throw Error("Codec " + repr tab.name + " is just ascii");
			local rp = repr tab.table;
			if (rp in byTable) {
				throw Error("Duplicate table: " +
					tab.name + " and " +
					byTable[rp].name + " (" + repr rp + ")");
			}
			byTable[rp] = tab;
		}
	}
	return result;
}

function parseDB(): {string: Object} {
	return parseDBFilename(fs.joinpath(fs.headof(__FILE__), "db"));
}

global final CODECS: {string: Object} = parseDB();

/* Hacky way to work around deemon taking forever to exit (XXX: might be a deemon bug?) */
Error.AppExit.atexit([]{ Error.AppExit.exit(0); });

function printCodecEnums() {
	local codecs_custom = [];
	local codecs_cp8 = [];
	local codecs_cp7l = [];
	local codecs_cp7h = [];
	local codecs_iso646 = [];
	local codecs_stateful = [];
	local codecs_mbcs = [];
	for (local name, codec: CODECS) {
		if (codec is CodePage) {
			switch (codec.getCpClass()) {
			case CP_CLASS_8:
				codecs_cp8.append(name);
				break;
			case CP_CLASS_7L:
				codecs_cp7l.append(name);
				break;
			case CP_CLASS_7H:
				codecs_cp7h.append(name);
				break;
			case CP_CLASS_ISO646:
				codecs_iso646.append(name);
				break;
			}
		} else if (codec is StatefulCodec) {
			codecs_stateful.append(name);
		} else if (codec is MbcsCodec) {
			codecs_mbcs.append(name);
		} else {
			codecs_custom.append(name);
		}
	}

	function printCodec(name: string, len: int) {
		local codec = CODECS[name];
		print("	", name, ",", " " * (len - #name),
			" /* ", ", ".join(
				for (local x: codec.aliases)
					if (x.ppCond == "1")
						repr(x.name)),
			" */");
	}

	function printCodecs(names: {string...}) {
		local maxLen = names.each.length > ...;
		for (local name: names)
			printCodec(name, maxLen);
	}

	codecs_custom.sort();
	codecs_cp8.sort();
	codecs_cp7l.sort();
	codecs_cp7h.sort();
	codecs_iso646.sort();
	codecs_stateful.sort();
	codecs_mbcs.sort();

	print("	/* Custom codecs */");
	printCodecs(codecs_custom);

	print;
	print("	/* 8-bit codepage codecs */");
	print("#define CODEC_CP_COUNT ", #codecs_cp8);
	if (codecs_cp8) {
		print("#define CODEC_CP_MIN ", codecs_cp8.first);
		printCodecs(codecs_cp8);
		print("#define CODEC_CP_MAX ", codecs_cp8.last);
	}

	print;
	print("	/* 7l codepage codecs */");
	print("#define CODEC_CP7L_COUNT ", #codecs_cp7l);
	if (codecs_cp7l) {
		print("#define CODEC_CP7L_MIN ", codecs_cp7l.first);
		printCodecs(codecs_cp7l);
		print("#define CODEC_CP7L_MAX ", codecs_cp7l.last);
	}

	print;
	print("	/* 7h codepage codecs */");
	print("#define CODEC_CP7H_COUNT ", #codecs_cp7h);
	if (codecs_cp7h) {
		print("#define CODEC_CP7H_MIN ", codecs_cp7h.first);
		printCodecs(codecs_cp7h);
		print("#define CODEC_CP7H_MAX ", codecs_cp7h.last);
	}

	print;
	print("	/* iso646 codepage codecs */");
	print("#define CODEC_ISO646_COUNT ", #codecs_iso646);
	if (codecs_iso646) {
		print("#define CODEC_ISO646_MIN ", codecs_iso646.first);
		printCodecs(codecs_iso646);
		print("#define CODEC_ISO646_MAX ", codecs_iso646.last);
	}

	print;
	print("	/* Stateful codepage codecs */");
	print("#define CODEC_STATEFUL_COUNT ", #codecs_stateful);
	if (codecs_stateful) {
		print("#define CODEC_STATEFUL_MIN ", codecs_stateful.first);
		printCodecs(codecs_stateful);
		print("#define CODEC_STATEFUL_MAX ", codecs_stateful.last);
	}

	print;
	print("	/* MBCS codepage codecs */");
	print("#define CODEC_MBCS_COUNT ", #codecs_mbcs);
	if (codecs_mbcs) {
		print("#define CODEC_MBCS_MIN ", codecs_mbcs.first);
		printCodecs(codecs_mbcs);
		print("#define CODEC_MBCS_MAX ", codecs_mbcs.last);
	}
}



function printCodecNameDB() {
	local longestAliasLength = 0;
	@@Maps alias -> ppCond -> codec
	local aliasToCodecMapping: {string: {string: Object}} = Dict();
	print("struct codec_name_db_struct {");
	print("	char _hdr_nul[2];");
	local longestDbNameLength = 0;
	for (local name: CODECS.keys.sorted()) {
		local codec = CODECS[name];
		print;
		print("	/* ", name, " */");
		local base = dbFieldName(name);
		local longestAliasNameLenLen = #str((codec.aliases.each.name.length + 1) > ...);
		local prevPpCond = "1";
		for (local i, alias: util.enumerate(codec.aliases)) {
			local name = alias.name;
			local lenPlusOne = str(#name+1);
			if (prevPpCond != alias.ppCond) {
				if (prevPpCond != "1")
					print("#endif /* ", prevPpCond, " */");
				if (alias.ppCond != "1")
					print("#if ", alias.ppCond);
				prevPpCond = alias.ppCond;
			}
			local dbName = "{}_{}".format({ base, i });
			if (longestDbNameLength < #dbName)
				longestDbNameLength = #dbName;
			print("	char ", dbName, "[", lenPlusOne, "]; ",
				" " * (longestAliasNameLenLen - #lenPlusOne),
				"/* ", repr name, " */");
			local map = aliasToCodecMapping.get(name);
			if (map is none)
				aliasToCodecMapping[name] = map = Dict();
			assert alias.ppCond !in map,
				"name:" + repr name + "\n"
				"map: " + repr map.keys + "\n"
				"ppCond:" + repr alias.ppCond;
			map[alias.ppCond] = codec;
		}
		if (prevPpCond != "1")
			print("#endif /* ", prevPpCond ?: "...", " */");
		print("	char ", base, "_nul;");
	}
	print("};");
	print;
	print("/* Name database */");
	print("PRIVATE struct codec_name_db_struct const codec_name_db = {");
	print("	{ 0, 0 },");
	for (local name: CODECS.keys.sorted()) {
		local codec = CODECS[name];
		print;
		print("	/* ", name, " */");
		local prevPpCond = "1";
		for (local i, alias: util.enumerate(codec.aliases)) {
			local name = alias.name;
			local lenPlusOne = str(#name+1);
			if (prevPpCond != alias.ppCond) {
				if (prevPpCond != "1")
					print("#endif /* ", prevPpCond, " */");
				if (alias.ppCond != "1")
					print("#if ", alias.ppCond);
				prevPpCond = alias.ppCond;
			}
			print("	", repr name, ",");
		}
		if (prevPpCond != "1")
			print("#endif /* ", prevPpCond ?: "...", " */");
		print("	0,");
	}
	print("};");
	print;
	print("STATIC_ASSERT((codec_name_db_offset_t)-1 >= sizeof(struct codec_name_db_struct));");
	/* Offset tables. */
	local longestAliasLength = aliasToCodecMapping.keys.each.length > ...;
	print("#define CODE_NAME_MAXLEN ", longestAliasLength);
	print("struct codec_db_entry {");
	print("	codec_name_db_offset_t cdbe_name;  /* Offset to name within `codec_name_db' */");
	print("	iconv_codec_t          cdbe_codec; /* The associated codec. */");
	print("};");
	print;
	print("PRIVATE struct codec_db_entry const codec_db[] = {");
	for (local name: aliasToCodecMapping.keys.sorted()) {
		local lastPpCond = none;
		for (local ppCond, codec: aliasToCodecMapping[name]) {
			if (lastPpCond is none) {
				if (ppCond != "1") {
					print("#if ", ppCond);
					lastPpCond = ppCond;
				}
			} else if (ppCond != "1") {
				lastPpCond = "";
				print("#elif ", ppCond);
			}
			local index = (codec.aliases.each.name as Sequence).index(name);
			local dbName = "{}_{}".format({ dbFieldName(codec.name), index });
			print("	{ offsetof(struct codec_name_db_struct, ", dbName, "),",
				" /* ", " " * (longestDbNameLength - #dbName),
				repr name, " " * (longestAliasLength - #name),
				" */ ", codec.name, " },");
		}
		if (lastPpCond !is none)
			print("#endif /* ", lastPpCond ?: "..." , " */");
	}
	print("};");
}

function printCodepageDatabase(kind: int) {
	local cpInsert = {
		CP_CLASS_8  : "",
		CP_CLASS_7L : "7l",
		CP_CLASS_7H : "7h",
	}[kind];
	local cpInsertUpper = cpInsert.upper();
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is CodePage && codec.getCpClass() == kind)
			codecs.append(codec);
	}
	codecs.sort(CodePage.name);
	print("/* Codepage database blob. */");
	print("struct iconv_cp", cpInsert, "_database {");
	for (local cp: codecs) {
		local table = cp.table;
		local shift = 0;
		if (kind == CP_CLASS_7L) {
			table = table[:128];
		} else if (kind == CP_CLASS_7H) {
			table = table[128:];
			shift = 128;
		}
		local encode_table = getEncodeTable(table, shift);
		local len = str(#encode_table);
		print("	struct { char16_t _d[", #table, "]; struct iconv_codepage_encode_entry _e[", len, "]; ",
			" " * (3 - #len), " } ", dbFieldName(cp.name), ";");
	}
	print("};");

	print;
	print("/* Codepage database offsets. */");
	print("STATIC_ASSERT((libiconv_cp", cpInsert, "_offset_t)-1 >= sizeof(struct iconv_cp", cpInsert, "_database));");
	print("STATIC_ASSERT(CODEC_CP", cpInsertUpper, "_MIN + ", (#codecs-1), " == CODEC_CP", cpInsertUpper, "_MAX);");
	for (local i, cp: util.enumerate(codecs))
		print("STATIC_ASSERT(CODEC_CP", cpInsertUpper, "_MIN + ", i, " == ", cp.name, ");");
	print("INTERN_CONST libiconv_cp", cpInsert, "_offset_t const libiconv_cp", cpInsert, "_offsets[", #codecs, "] = {");
	for (local cp: codecs)
		print("	/* [", cp.name, " - CODEC_CP", cpInsertUpper, "_MIN] = */ offsetof(struct iconv_cp", cpInsert, "_database, ", dbFieldName(cp.name), "),");
	print("};");

	print;
	print("/* The actual codepage database. */");
	print("INTERN_CONST struct iconv_cp", cpInsert, "_database const libiconv_cp", cpInsert, "_db = {");
	for (local cp: codecs) {
		local table = cp.table;
		local shift = 0;
		if (kind == CP_CLASS_7L) {
			table = table[:128];
		} else if (kind == CP_CLASS_7H) {
			table = table[128:];
			shift = 128;
		}
		local encode_table = getEncodeTable(table, shift);
		print("	/* .", dbFieldName(cp.name), " = */ { {");
		for (local i, l: util.enumerate(table.segments(8))) {
			local lo = shift + (i * 8);
			print("		", ", ".join(for (local x: l) "0x" + x.hex()[2:].zfill(4)), ", /* ",
				lo.hex()[2:].zfill(2), "h-",
				(lo + 7).hex()[2:].zfill(2), "h */");
		}
		print("	}, {");
		for (local i, ord: util.enumerate(encode_table.keys.sorted())) {
			if ((i % 4) == 0)
				print("		"),;
			local cp_ord = encode_table[ord];
			print("{ 0x", ord.hex()[2:].zfill(4), ", 0x", cp_ord.hex()[2:].zfill(2)),;
			if (i == 0) {
				local count = #encode_table;
				if (kind == CP_CLASS_8)
					--count;
				print(", ", count),;
			} else if (i == 1 && kind != CP_CLASS_7H) {
				local repl_char = encode_table.get("?".ord());
				if (repl_char is none) repl_char = encode_table.get(".".ord());
				if (repl_char is none) repl_char = encode_table.get("-".ord());
				if (repl_char is none) repl_char = 0;
				print(", 0x", repl_char.hex()[2:].zfill(2)),;
			}
			print(" },"),;
			if ((i % 4) == 3)
				print;
			else if (i != #encode_table - 1) {
				print(" "),;
			}
		}
		if ((#encode_table % 4) != 0)
			print;
		print("	} },");
	}
	print("};");
}

function printCp8Database() -> printCodepageDatabase(CP_CLASS_8);
function printCp7lDatabase() -> printCodepageDatabase(CP_CLASS_7L);
function printCp7hDatabase() -> printCodepageDatabase(CP_CLASS_7H);

function printCpIso646Database() {
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is CodePage && codec.getCpClass() == CP_CLASS_ISO646)
			codecs.append(codec);
	}
	codecs.sort(CodePage.name);
	for (local i, codec: util.enumerate(codecs))
		print("STATIC_ASSERT(CODEC_ISO646_MIN + ", i, " == ", codec.name, ");");
	print("INTERN_CONST struct iconv_iso646_codepage const libiconv_iso646_pages[", #codecs, "] = {");
	local longestNameLen = codecs.each.name.length > ...;
	for (local codec: codecs) {
		print("	/* [", codec.name, " - CODEC_ISO646_MIN]",
			" " * (longestNameLen - #codec.name), " = */ { { ",
			", ".join(
				for (local x: ISO646_OVERRIDE_ORDINALS)
					"0x" + codec.table[x].hex()[2:].zfill(4)),
			" } },");
	}
	print("};");
}


class ExStatefulCodec {
	this = default;
	public member codec: StatefulCodec;
	public member isc_rab_minoff: int;
	public member isc_rab_maxoff: int;
	public member isc_db_ranges: {(int, int)...} = [];
	public member isc_rab: {int...} = [];
	public member isc_u16: {int...} = [];
	public member isc_u32: {int...} = [];
	public member isc_encode_rab_minoff: int;
	public member isc_encode_rab_maxoff: int;
	public member isc_encode_repl: int;
	public member isc_encode_ranges: {(int, int)...} = [];
	public member isc_encode_rab: {int...} = [];
	public member isc_encode_tab: {int...} = [];
	public member isc_encode_2ch: {(int, int)...} = [];
	public member isc_encode_c32: {(int, int)...} = [];
}

function printCompressed(items: {Object...}, linePrefix: string, maxLineLen: int = 256) {
	local indent = #linePrefix;
	local isFirst = true;
	for (local x: items) {
		if (!isFirst) {
			print(","),;
			++indent;
		}
		isFirst = false;
		if (indent >= maxLineLen) {
			print;
			print(linePrefix),;
			indent = #linePrefix;
		}
		x = str(x);
		indent += #x;
		print(x),;
	}
}


function printCpStatefulDatabase() {
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is StatefulCodec)
			codecs.append(codec);
	}
	codecs.sort(StatefulCodec.name);
	local exCodecs: {ExStatefulCodec...} = [];

	/* Generate extended codec data. */
	for (local codec: codecs) {
		@@List of (cp_min, count, uni_min | {uni_ord...})
		local ranges: (int, int, int) = [];
		for (local cp_ord = 0; cp_ord <= 0xffff;) {
			local uni_ord = codec.db_table.get(cp_ord, 0);
			if (uni_ord !is int) {
				ranges.append((cp_ord, 1, (uni_ord,)));
				++cp_ord;
				continue;
			}
			if (uni_ord > 0xffff)
				goto do_random_range;
			local count = 1;
			for (;;) {
				local cp_next = cp_ord + count;
				if (cp_next > 0xffff)
					break;
				local uni_next = codec.db_table.get(cp_next, 0);
				if (uni_next !is int || uni_next > 0xffff)
					break;
				if (uni_next != (uni_ord ? uni_ord + count : 0))
					break;
				++count;
			}
			if (count == 1) {
do_random_range:
				local randomRangeStart = cp_ord;
				local randomRangeUnicode = [uni_ord];
				for (;;) {
					++cp_ord;
					local uni_ord_0 = codec.db_table.get(cp_ord, 0);
					local uni_ord_1 = codec.db_table.get(cp_ord+1, 0);
					local uni_ord_2 = codec.db_table.get(cp_ord+2, 0);
					if (uni_ord_0 !is int || (uni_ord_0 > 0xffff != uni_ord > 0xffff))
						break;
					if (uni_ord_1 is int && uni_ord_2 is int &&
					    ((uni_ord_0 == 0 && uni_ord_1 == 0 && uni_ord_2 == 0) ||
					     (uni_ord_0+1 == uni_ord_1 && uni_ord_1+1 == uni_ord_2)))
						break;
					randomRangeUnicode.append(uni_ord_0);
				}
				randomRangeUnicode = Tuple(randomRangeUnicode);
				if (#randomRangeUnicode == 1 && uni_ord <= 0xffff &&
				    !(uni_ord == randomRangeStart && randomRangeStart != 0)) {
					cp_ord = randomRangeStart;
					goto do_add_identity_range;
				}
				assert cp_ord - randomRangeStart == #randomRangeUnicode;
				ranges.append((randomRangeStart, #randomRangeUnicode, randomRangeUnicode));
			} else {
do_add_identity_range:
				if (uni_ord == cp_ord && cp_ord != 0)
					goto do_random_range; /* unicode-offset == 0 has special meaning!  */
				assert uni_ord <= 0xffff;
				ranges.append((cp_ord, count, uni_ord));
				cp_ord += count;
			}
		}
		local uniOffsetsInUse = [];
		local random_access_count = 0;
		local random_access_blocks = 0;
		for (local cp_min, count, content: ranges) {
			if (content is int && content <= 0xffff) {
				assert content != cp_min || cp_min == 0,
					"This should have been handled by `goto do_random_range'";
				local unicode_offset = content ? (content - cp_min) & 0xffff : 0;
				uniOffsetsInUse.append(unicode_offset);
			} else {
				random_access_count += count;
				++random_access_blocks;
			}
		}

		/* Find the largest range of free slots between uniOffsetsInUse
		 * This range must be large enough to hold random_access_blocks */
		uniOffsetsInUse.sort();
		local largestRangeStart = 0;
		local largestRangeSize = 0;
		for (local i = 0; i < #uniOffsetsInUse; ++i) {
			local start = uniOffsetsInUse[i] + 1;
			local end = (i+1) >= #uniOffsetsInUse ? 0x10000 : uniOffsetsInUse[i+1];
			local count = end - start;
			if (largestRangeSize < count) {
				largestRangeStart = start;
				largestRangeSize = count;
			}
		}
		if (random_access_blocks > largestRangeSize) {
			throw Error(codec.name + ": Largest range size " + largestRangeSize +
				" is smaller than # of random access block " + random_access_blocks);
		}

		local exCodec = ExStatefulCodec(codec: codec);
		exCodecs.append(exCodec);

		/* Calculate extended codec data. */
		for (local cp_min, count, content: ranges) {
			if (content is int && content <= 0xffff) {
				assert content != cp_min || cp_min == 0,
					"This should have been handled by `goto do_random_range'";
				local unicode_offset = content ? (content - cp_min) & 0xffff : 0;
				assert !(unicode_offset >= largestRangeStart &&
				         unicode_offset < largestRangeStart + largestRangeSize);
				/* Unicode identity range */
				exCodec.isc_db_ranges.append((cp_min, unicode_offset));
			} else if (content is int) {
				assert content > 0xffff; /* 32-bit unicode character */
				assert !(content & 0x80000000), "Not allowed";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
				exCodec.isc_u32.append(content | 0x80000000);
			} else if (#content == 1 && content.first !is int) {
				/* Decode-to-2-character sequence */
				local a, b = content.first...;
				assert !(a & 0x8000), "Not allowed";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
				exCodec.isc_u32.append((a << 16) | b);
			} else {
				/* Random access range. */
				local is32 = content.first > 0xffff;
				for (local x: content)
					assert (x > 0xffff) == is32, "All entires must share the same is32 property!";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				if (is32) {
					exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
					for (local x: content)
						exCodec.isc_u32.append(x | 0x80000000);
				} else {
					exCodec.isc_rab.append(#exCodec.isc_u16);
					exCodec.isc_u16.extend(content);
				}
			}
		}

		assert exCodec.isc_db_ranges.first.first == 0, "The range table must start with CP_ORD=0";
		assert #exCodec.isc_rab <= largestRangeSize, "Somehow we used more than we thought?";
		exCodec.isc_rab_minoff = largestRangeStart;
		exCodec.isc_rab_maxoff = exCodec.isc_rab_minoff + #exCodec.isc_rab - 1;

		/* Relocate RAB offsets to use use the correct u16 table size */
		for (local i: [:#exCodec.isc_rab]) {
			local offset = exCodec.isc_rab[i];
			if (offset >= 0x80000000) {
				offset -= 0x80000000;
				offset += #exCodec.isc_u16;
				exCodec.isc_rab[i] = offset;
			}
		}

		/* Generate encode data */

		@@Sorted list of (uni_ord, cp_ord)
		local encodeTable: {int: int} = Dict();
		local encodeTable32: {int: int} = Dict();
		local encodeTable2Char: {int: {int: int}} = Dict();
		for (local cp_ord, uni_ord: codec.db_table) {
			if (uni_ord !is int) {
				assert #uni_ord == 2;
				assert uni_ord.first <= 0xffff;
				assert uni_ord.last <= 0xffff;
				local subDict = encodeTable2Char.get(uni_ord.first);
				if (subDict is none)
					encodeTable2Char[uni_ord.first] = subDict = Dict();
				subDict[uni_ord.last] = cp_ord;
				continue;
			}
			if (cp_ord == 0)
				continue;
			local usedTable = uni_ord > 0xffff ? encodeTable32 : encodeTable;
			if (uni_ord in usedTable)
				cp_ord = { cp_ord, usedTable[uni_ord] } < ...;
			usedTable[uni_ord] = cp_ord;
		}
		for (local i: [:256]) {
			local uni = codec.sb_table[i];
			if (uni != 0)
				encodeTable[uni] = i;
		}
		encodeTable[0] = 0;

		@@List of (uni_ord, count, cp_ord | {cp_ord...})
		@@When `cp_ord' is  0, it's  an undefined  range
		local encodeRanges: {(int, int, int | {int...})...} = [];
		for (local uni_ord = 0; uni_ord <= 0xffff;) {
			local cp_ord = encodeTable.get(uni_ord, 0);
			local count = 1;
			local twochar = encodeTable2Char.get(uni_ord);
			if (twochar) {
				/* Handle multi-char sequences. */
				assert cp_ord != 0;
				encodeRanges.append((uni_ord, 1, 0x80000000 + #exCodec.isc_encode_2ch));
				for (local uni2_ord: twochar.keys.sorted()) {
					exCodec.isc_encode_2ch.append((uni2_ord, twochar[uni2_ord]));
				}
				/* Fallback when the follow-up character isn't one of the special ones. */
				exCodec.isc_encode_2ch.append((0, cp_ord));
				++uni_ord;
				continue;
			}
			for (;;) {
				local uni_next = uni_ord + count;
				if (uni_next > 0xffff)
					break;
				if (uni_next in encodeTable2Char)
					break;
				local cp_next = encodeTable.get(uni_next, 0);
				if (cp_next != (cp_ord ? cp_ord + count : 0))
					break;
				++count;
			}
			if (count == 1) {
do_encode_random_range:
				local randomRangeStart = uni_ord;
				local randomRangeCp = [cp_ord];
				for (;;) {
					++uni_ord;
					if (uni_ord in encodeTable2Char)
						break;
					local cp_ord_0 = encodeTable.get(uni_ord, 0);
					local cp_ord_1 = encodeTable.get(uni_ord+1, 0);
					local cp_ord_2 = encodeTable.get(uni_ord+2, 0);
					if (cp_ord_0 == 0 && cp_ord_1 == 0 && cp_ord_2 == 0)
						break;
					if (cp_ord_0+1 == cp_ord_1 && cp_ord_1+1 == cp_ord_2 && cp_ord_0 != uni_ord)
						break;
					randomRangeCp.append(cp_ord_0);
				}
				randomRangeCp = Tuple(randomRangeCp);
				if (#randomRangeCp == 1 && !(cp_ord == randomRangeStart)) {
					uni_ord = randomRangeStart;
					goto do_add_encode_identity_range;
				}
				assert uni_ord - randomRangeStart == #randomRangeCp;
				encodeRanges.append((randomRangeStart, #randomRangeCp, randomRangeCp));
			} else {
do_add_encode_identity_range:
				if (uni_ord == cp_ord)
					goto do_encode_random_range; /* cp-offset == 0 has special meaning!  */
				encodeRanges.append((uni_ord, count, cp_ord));
				uni_ord += count;
			}
		}

		local cpOffsetsInUse = [];
		local random_access_count = 0;
		local random_access_blocks = 0;
		for (local uni_min, count, content: encodeRanges) {
			if (content is int && !(content & 0x80000000)) {
				assert content != uni_min,
					"This should have been handled by `goto do_encode_random_range'";
				local cp_offset = content ? (content - uni_min) & 0xffff : 0;
				cpOffsetsInUse.append(cp_offset);
			} else {
				random_access_count += count;
				++random_access_blocks;
			}
		}

		/* Find the largest range of free slots between  cpOffsetsInUse
		 * This range must be large enough to hold random_access_blocks */
		cpOffsetsInUse.sort();
		local largestRangeStart = 0;
		local largestRangeSize = 0;
		for (local i = 0; i < #cpOffsetsInUse; ++i) {
			local start = cpOffsetsInUse[i] + 1;
			local end = (i+1) >= #cpOffsetsInUse ? 0x10000 : cpOffsetsInUse[i+1];
			local count = end - start;
			if (largestRangeSize < count) {
				largestRangeStart = start;
				largestRangeSize = count;
			}
		}

		/* Generate encode ranges. */
		for (local uni_min, count, content: encodeRanges) {
			if (content is int) {
				if (content & 0x80000000) {
					/* 2-character entry. */
					assert count == 1;
					exCodec.isc_encode_ranges.append((uni_min,
						largestRangeStart + #exCodec.isc_encode_rab));
					exCodec.isc_encode_rab.append(content);
				} else {
					local cp_offset = content ? (content - uni_min) & 0xffff : 0;
					assert !(cp_offset >= largestRangeStart &&
					         cp_offset < largestRangeStart + largestRangeSize);
					exCodec.isc_encode_ranges.append((uni_min, cp_offset));
				}
			} else {
				/* Random access range. */
				exCodec.isc_encode_ranges.append((uni_min,
					largestRangeStart + #exCodec.isc_encode_rab));
				exCodec.isc_encode_rab.append(#exCodec.isc_encode_tab);
				exCodec.isc_encode_tab.extend(content);
			}
		}
		assert exCodec.isc_encode_ranges.first.first == 0, "The encode range table must start with UNI_ORD=0";
		exCodec.isc_encode_rab_minoff = largestRangeStart;
		exCodec.isc_encode_rab_maxoff = largestRangeStart + #exCodec.isc_encode_rab - 1;
		local repl_char = encodeTable.get("?".ord());
		if (repl_char is none || repl_char > 0xff) repl_char = encodeTable.get(".".ord());
		if (repl_char is none || repl_char > 0xff) repl_char = encodeTable.get("-".ord());
		if (repl_char is none || repl_char > 0xff) repl_char = 0;
		exCodec.isc_encode_repl = repl_char;

		assert #exCodec.isc_encode_rab <= largestRangeSize;

		/* Relocate 2-character entry offsets. */
		for (local i: [:#exCodec.isc_encode_rab]) {
			local offset = exCodec.isc_encode_rab[i];
			if (offset & 0x80000000) {
				offset = (offset & ~0x80000000) + #exCodec.isc_encode_tab;
				exCodec.isc_encode_rab[i] = offset;
			}
		}

		/* Generate the encode-uni32 table. */
		for (local uni: encodeTable32.keys.sorted()) {
			exCodec.isc_encode_c32.append((uni, encodeTable32[uni]));
		}
		assert #exCodec.isc_encode_2ch <= 0xff;
		assert #exCodec.isc_encode_c32 <= 0xffff;

		/* Ensure that tables containing 32-bit integers are properly aligned. */
		local offset = 22 +                /* offsetof(isc_db_ranges) */
			(#exCodec.isc_db_ranges * 4) + /* sizeof(isc_db_ranges) */
			2 +                            /* sizeof(isc_db_ranges_end) */
			(#exCodec.isc_rab * 2) +       /* sizeof(isc_rab) */
			(#exCodec.isc_u16 * 2);        /* sizeof(isc_u16) */
		if (exCodec.isc_u32) {
			/* Ensure that `isc_u32' is aligned. */
			if (offset & 2) {
				/* Add an unused no-op entry to `isc_u16' */
				exCodec.isc_u16.append(0);
				offset += 2;
			}
			offset += (#exCodec.isc_u32 * 4); /* sizeof(isc_u32) */
		}
		offset += (#exCodec.isc_encode_ranges * 4);  /* sizeof(isc_encode_ranges) */
		offset += 2;                                 /* sizeof(isc_encode_ranges_end) */
		offset += (#exCodec.isc_encode_rab * 2);     /* sizeof(isc_encode_rab) */
		offset += (#exCodec.isc_encode_tab * 2);     /* sizeof(isc_encode_tab) */
		offset += (#exCodec.isc_encode_2ch * 4);     /* sizeof(isc_encode_2ch) */
		if (exCodec.isc_encode_c32) {
			/* Ensure that `isc_encode_c32' is aligned. */
			if (offset & 2) {
				/* Add an unused no-op entry to `isc_encode_tab' */
				exCodec.isc_encode_tab.append(0);
				offset += 2;
			}
			offset += (#exCodec.isc_encode_c32 * 8); /* sizeof(isc_encode_c32) */
		}
	}

	/* With everything calculated, print the database controller. */
	print("struct iconv_stateful_database {");
	for (local exCodec: exCodecs) {
		print;
		print("	/* ", exCodec.codec.name, " */");
		print("	struct {");
		/* For safety, manually count the # of different ranges. */
		local numRandomAccess = 0;
		local numIdentity = 0;
		for (local isr_cp_ord, isr_uni_off: exCodec.isc_db_ranges) {
			if (isr_uni_off >= exCodec.isc_rab_minoff &&
			    isr_uni_off <= exCodec.isc_rab_maxoff)
				++numRandomAccess;
			else {
				++numIdentity;
			}
		}
		/* Then verify that the expected numbers are correct! */
		assert numRandomAccess == #exCodec.isc_rab;
		assert numRandomAccess + numIdentity == #exCodec.isc_db_ranges;
		print("		/* Random access ranges: ", numRandomAccess.hex());
		print("		 * Identity ranges:      ", numIdentity.hex(), " */");
		print("		char16_t                           _sb[256];");
		print("		uint16_t                           _db_count;          /* == ", (#exCodec.isc_db_ranges).hex(), " */");
		print("		uint16_t                           _u16_count;         /* == ", (#exCodec.isc_u16).hex(), " */");
		print("		uint16_t                           _u32_count;         /* == ", (#exCodec.isc_u32).hex(), " */");
		print("		uint16_t                           _rab_minoff;        /* == ", exCodec.isc_rab_minoff.hex(), " */");
		print("		uint16_t                           _rab_maxoff;        /* == ", exCodec.isc_rab_maxoff.hex(), " */");
		print("		uint16_t                           _encode_count;      /* == ", (#exCodec.isc_encode_ranges).hex(), " */");
		print("		uint16_t                           _encode_tab_count;  /* == ", (#exCodec.isc_encode_tab).hex(), " */");
		print("		uint16_t                           _encode_rab_minoff; /* == ", exCodec.isc_encode_rab_minoff.hex(), " */");
		print("		uint16_t                           _encode_rab_maxoff; /* == ", exCodec.isc_encode_rab_maxoff.hex(), " */");
		print("		uint8_t                            _encode_repl;       /* == ", exCodec.isc_encode_repl.hex(), " */");
		print("		uint8_t                            _encode_2ch_count;  /* == ", (#exCodec.isc_encode_2ch).hex(), " */");
		print("		uint16_t                           _encode_c32_count;  /* == ", (#exCodec.isc_encode_c32).hex(), " */");
		print("		struct iconv_stateful_range        _db_ranges[", (#exCodec.isc_db_ranges).hex(), "];");
		print("		uint16_t                           _db_ranges_end;");
		print("		uint16_t                           _rab[", (#exCodec.isc_rab).hex(), "];");
		print("		char16_t                           _u16[", (#exCodec.isc_u16).hex(), "];");
		if (exCodec.isc_u32) {
			print("		uint32_t                           _u32[", (#exCodec.isc_u32).hex(), "];");
		}
		print("		struct iconv_stateful_encode_range _encode_ranges[", (#exCodec.isc_encode_ranges).hex(), "];");
		print("		uint16_t                           _encode_ranges_end;");
		print("		uint16_t                           _encode_rab[", (#exCodec.isc_encode_rab).hex(), "];");
		print("		uint16_t                           _encode_tab[", (#exCodec.isc_encode_tab).hex(), "];");
		if (exCodec.isc_encode_2ch) {
			print("		struct iconv_stateful_2char_encode _encode_2ch[", (#exCodec.isc_encode_2ch).hex(), "];");
		}
		if (exCodec.isc_encode_c32) {
			print("		struct iconv_stateful_c32_encode   _encode_c32[", (#exCodec.isc_encode_c32).hex(), "];");
		}
		print("	} ", dbFieldName(exCodec.codec.name), ";");
	}
	print("};");

	/* Print the offset table. */
	for (local i, exCodec: util.enumerate(exCodecs))
		print("STATIC_ASSERT(CODEC_STATEFUL_MIN + ", i, " == ", exCodec.codec.name, ");");
	print("INTERN_CONST libiconv_stateful_offset_t const libiconv_stateful_offsets[", #exCodecs, "] = {");
	for (local exCodec: exCodecs)
		print("	/* [", exCodec.codec.name, " - CODEC_STATEFUL_MIN] = */ offsetof(struct iconv_stateful_database, ", dbFieldName(exCodec.codec.name), "),");
	print("};");

	/* Now print the database controller contents. */
	print("INTERN_CONST struct iconv_stateful_database const libiconv_stateful_db = {");
	for (local exCodec: exCodecs) {
		print;
		print("	/* .", dbFieldName(exCodec.codec.name), " = */ {");
		print("		{"),; /* _sb */
		printCompressed(exCodec.codec.sb_table, "		 ");
		print("},");
		print("		", #exCodec.isc_db_ranges, ",");              /* _db_count */
		print("		", #exCodec.isc_u16, ",");                    /* _u16_count */
		print("		", #exCodec.isc_u32, ",");                    /* _u32_count */
		print("		", exCodec.isc_rab_minoff, ",");              /* _rab_minoff */
		print("		", exCodec.isc_rab_maxoff, ",");              /* _rab_maxoff */
		print("		", (#exCodec.isc_encode_ranges).hex(), ",");  /* _encode_count */
		print("		", (#exCodec.isc_encode_tab).hex(), ",");     /* _encode_tab_count */
		print("		", exCodec.isc_encode_rab_minoff.hex(), ","); /* _encode_rab_minoff */
		print("		", exCodec.isc_encode_rab_maxoff.hex(), ","); /* _encode_rab_maxoff */
		print("		", exCodec.isc_encode_repl.hex(), ",");       /* _encode_repl */
		print("		", (#exCodec.isc_encode_2ch).hex(), ",");     /* _encode_2ch_count */
		print("		", (#exCodec.isc_encode_c32).hex(), ",");     /* _encode_c32_count */
		print("		{"),; /* _db_ranges */
		printCompressed(
			(for (local isr_cp_ord, isr_uni_off: exCodec.isc_db_ranges)
				"{" + isr_cp_ord + "," + isr_uni_off + "}"),
			"		 ");
		print("},"),;
		print("		0xffff,"); /* _db_ranges_end */
		print("		{"),; /* _rab */
		printCompressed(exCodec.isc_rab, "		 ");
		print("},");
		print("		{"),; /* _u16 */
		printCompressed(exCodec.isc_u16, "		 ");
		print("},");
		if (exCodec.isc_u32) {
			print("		{"),; /* _u32 */
			printCompressed(exCodec.isc_u32, "		 ");
			print("},");
		}
		print("		{"),; /* _encode_ranges */
		printCompressed(
			(for (local iser_uni_ord, iser_cp_off: exCodec.isc_encode_ranges)
				"{" + iser_uni_ord + "," + iser_cp_off + "}")
			, "		 ");
		print("},");
		print("		._encode_ranges_end = 0xffff,");
		print("		{"),; /* _encode_rab */
		printCompressed(exCodec.isc_encode_rab, "		 ");
		print("},");
		print("		{"),; /* _encode_tab */
		printCompressed(exCodec.isc_encode_tab, "		 ");
		print("},");
		if (exCodec.isc_encode_2ch) {
			print("		{"),; /* _encode_2ch */
			printCompressed(
				(for (local is2ce_uni2, is2ce_cp: exCodec.isc_encode_2ch)
					"{" + is2ce_uni2 + "," + is2ce_cp + "}")
				, "		 ");
			print("},");
		}
		if (exCodec.isc_encode_c32) {
			print("		{"),; /* _encode_c32 */
			printCompressed(
				(for (local isc32e_uni, isc32e_cp: exCodec.isc_encode_c32)
					"{" + isc32e_uni + "," + isc32e_cp + "}")
				, "		 ");
			print("},");
		}
		print("	},");
	}
	print("};");
}

#define ICONV_MBCS_BYTE2_RANGE_TYPE_EOF   0 /* Range list end (sentinel) */
#define ICONV_MBCS_BYTE2_RANGE_TYPE_LIN   1 /* Linear unicode mapping */
#define ICONV_MBCS_BYTE2_RANGE_TYPE_ARR   2 /* 16-bit array of unicode ordinals */
#define ICONV_MBCS_BYTE2_RANGE_TYPE_ARR32 3 /* 32-bit array of unicode ordinals */
#define ICONV_MBCS_BYTE2_RANGE_TYPE_TAB   4 /* Another table (offset from code-page start to another array
                                             * of `struct iconv_mbcs_byte2_range' to-be used for decoding) */
global ExMbcsByte2Table;
class ExMbcsByte2Range {
	this = default;
	public member imc_type: int;
	public member imc_size: int;
	public member imc_cpmin: int;
	public member imc_cpmax: int;
	public member imc_lin: int = none;
	public member imc_arr: {int...} = none;
	public member imc_tab: ExMbcsByte2Table = none;
}
class ExMbcsByte2Table {
	this = default;
	public member _firstbyte: {int...} = [];
	public member offset: int; /* offsetof() this table */
	public member sizeof: int; /* sizeof() this table */
	public member ranges: {ExMbcsByte2Range...} = []; /* Ranges */
}

@@Given  a  table  for   mapping  the  second   byte  to  unicode,   convert  to  a   @ExMbcsByte2Table
@@This returns the created table, and a list of recursively created ables (excluding the primary table)
function createExMbcsByte2Table(map_table: {int: int | Object}): (ExMbcsByte2Table, {ExMbcsByte2Table...}) {
	local result = ExMbcsByte2Table();
	local recursiveTables = [];
	local table: {int | Object...} = [0] * 256;
	for (local cp, uni: map_table)
		table[cp] = uni;
	local i = 0;
	/* First the first non-empty codepage ordinal. */
	while (table[i] is int && table[i] == 0)
		++i;
	local maxOrd = 0xff;
	while (table[maxOrd] is int && table[maxOrd] == 0)
		--maxOrd;
	function hasConsecutiveNul(start: int, count: int): bool {
		if (start + count > maxOrd)
			return false;
		for (local i: [start:start + count]) {
			if (table[i] !is int || table[i] != 0)
				return false;
		}
		return true;
	}
	function hasConsecutive16Bit(start: int, count: int): bool {
		if (start + count > maxOrd)
			return false;
		for (local i: [start:start + count]) {
			if (table[i] !is int || table[i] > 0xffff)
				return false;
		}
		return true;
	}
	function hasConsecutiveLinear(start: int, count: int): bool {
		local start_uni = table[start];
		assert start_uni is int;
		local numLinear = 1;
		while (start + numLinear <= maxOrd && numLinear < count &&
		       table[start + numLinear] is int &&
		       table[start + numLinear] == start_uni + numLinear)
			++numLinear;
		return numLinear == count;
	}
	function shouldCreateLinearRange(start: int): bool {
		if (start >= maxOrd)
			return true;
		local start_uni = table[start];
		assert start_uni is int;
		local numLinear = 1;
		while (start + numLinear <= maxOrd && numLinear < 4 &&
		       table[start + numLinear] is int &&
		       table[start + numLinear] == start_uni + numLinear)
			++numLinear;
		/* Linear range are more efficient when there are
		 * at  least  4  consecutive  unicode   ordinals:
		 *
		 * 1 2 4 6 7                         1 2 4 6 7
		 * [-] [XXX]                         [XXXXXXX]
		 * 6b  10b    --> Total = 16b        14
		 *
		 * 1 2 3 5 7 9                       1 2 3 5 7 9
		 * [---] [XXX]                       [XXXXXXXXX]
		 * 6b    10b  --> Total = 16b        16b
		 *
		 * 1 2 3 4 5 7 9                     1 2 3 5 7 9 11
		 * [-----] [XXX]                     [XXXXXXXXXXXX]
		 * 6b      10b  --> Total = 16b      18b
		 *
		 * For 3  consecutive it's  just  as efficient,  but  at
		 * runtime, the array method is a bit faster to process. */
		if (numLinear >= 4)
			return true; /* Create a linear range for at least 4 consecutive */
		if (start + numLinear > maxOrd)
			return true; /* Create a linear range if this is the end of the list */
		return false;
	}

again_range:
	local uni = table[i];
	local range: ExMbcsByte2Range = ExMbcsByte2Range();
	range.imc_cpmin = i;
	if (uni !is int) {
		/* Recursively create another table. */
		range.imc_type = ICONV_MBCS_BYTE2_RANGE_TYPE_TAB;
		local tab, more = createExMbcsByte2Table(uni)...;
		for (local x: more)
			x._firstbyte.insert(0, i);
		tab._firstbyte.insert(0, i);
		recursiveTables.extend(more);
		recursiveTables.append(tab);
		range.imc_tab  = tab;
		++i;
	} else if (uni == 0) {
		/* Skip undefined range. */
		do {
			++i;
		} while (i <= maxOrd && table[i] is int && table[i] == 0);
		goto again_range;
	} else if (uni > 0xffff) {
		/* Force 32-bit range. */
		range.imc_type = ICONV_MBCS_BYTE2_RANGE_TYPE_ARR32;
		range.imc_arr  = [uni];
		for (;;) {
			++i;
			if (i > maxOrd)
				break;
			/* Encode as a 32-bit array until we reach 2 consecutive
			 * NUL-characters,   or   2   consecutive   <    0xffff. */
			if (hasConsecutiveNul(i, 2))
				break;
			if (hasConsecutive16Bit(i, 2))
				break;
			if (#range.imc_arr >= 126) /* (4+(126*4))/2 == 254 (prevent imc_size overflow) */
				break;
			if (table[i] !is int)
				break;
			range.imc_arr.append(table[i]);
		}
	} else if (shouldCreateLinearRange(i)) {
		range.imc_type = ICONV_MBCS_BYTE2_RANGE_TYPE_LIN;
		range.imc_lin  = (uni - i) & 0xffff;
		/* Skip consecutive linear mappings. */
		for (;;) {
			++i;
			if (i > maxOrd)
				break;
			++uni;
			if (table[i] !is int)
				break;
			if (table[i] != uni)
				break;
		}
	} else {
		/* Encode as a array until we reach 3 consecutive NUL-characters,
		 * or  4   consecutive  linear,   or   a  character   >   0xffff. */
		range.imc_type = ICONV_MBCS_BYTE2_RANGE_TYPE_ARR;
		range.imc_arr  = [uni];
		for (;;) {
			++i;
			if (i > maxOrd)
				break;
			if (hasConsecutiveLinear(i, 4))
				break;
			if (hasConsecutiveNul(i, 3))
				break;
			if (#range.imc_arr >= 253) /* (4+(253*2))/2 == 255 (prevent imc_size overflow) */
				break;
			uni = table[i];
			if (uni !is int || uni > 0xffff)
				break;
			range.imc_arr.append(uni);
		}
	}

	range.imc_cpmax = i - 1;
	/* Calculate range size */
	if (range.imc_type == ICONV_MBCS_BYTE2_RANGE_TYPE_LIN)
		range.imc_size = (4 + 2) / 2;
	else if (range.imc_type == ICONV_MBCS_BYTE2_RANGE_TYPE_ARR)
		range.imc_size = (4 + 2 * #range.imc_arr) / 2;
	else if (range.imc_type == ICONV_MBCS_BYTE2_RANGE_TYPE_ARR32)
		range.imc_size = (4 + 4 * #range.imc_arr) / 2;
	else if (range.imc_type == ICONV_MBCS_BYTE2_RANGE_TYPE_TAB)
		range.imc_size = (4 + 2) / 2;
	else {
		assert false, "Bad type";
	}
	assert range.imc_size <= 0xff, "Internal error: range too large";
	result.ranges.append(range);
	if (i <= maxOrd)
		goto again_range;

	/* Calculate the total size. */
	local size = 0;
	for (local r: result.ranges)
		size += r.imc_size * 2 + 2; /* +2 for the trailing _eof_type + _eof_size */
	result.sizeof = size;
	return (result, recursiveTables);
}

class ExMbcsCodec {
	this = default;
	public member codec: MbcsCodec;
	public member imc_1byte: {int...} = [0] * 256;
	public member imc_offidx_min: int;
	public member imc_offidx_max: int;
	public member imc_offtab: {int...} = [];
#define SIZEOF__imc_offtab__elements 2
	public member byte2_tables: {ExMbcsByte2Table...} = [];
}

function createExMbcsCodec(codec: MbcsCodec): ExMbcsCodec {
	local result: ExMbcsCodec = ExMbcsCodec(codec: codec);
	local onebyte_uni: {int...} = []; /* List of used unicode ordinals in 1-byte characters */
	local twobyte_offset = 512 + 4; /* offsetof(struct iconv_mbcs_codepage, imc_offtab) */
	for (local i: [:256]) {
		local val = codec.map.get(i, 0);
		if (val is int) {
			assert val <= 0xffff;
			result.imc_1byte[i] = val;
			onebyte_uni.append(val);
		} else {
			local tab: ExMbcsByte2Table, more: {ExMbcsByte2Table...};
			tab, more = createExMbcsByte2Table(val)...;
			for (local x: more)
				x._firstbyte.insert(0, i);
			tab._firstbyte.insert(0, i);
			result.imc_1byte[i] = 0x10000 + #result.imc_offtab; /* Relocated later. */
			assert twobyte_offset <= 0xffff;
			result.imc_offtab.append(twobyte_offset);
			tab.offset = twobyte_offset;
			result.byte2_tables.append(tab);
			twobyte_offset += tab.sizeof;
			for (local x: more) {
				assert twobyte_offset <= 0xffff;
				x.offset = twobyte_offset;
				result.byte2_tables.append(x);
				twobyte_offset += x.sizeof;
			}
		}
	}

	/* Relocate 2-byte offsets */
	local offtab_size = #result.imc_offtab * SIZEOF__imc_offtab__elements;
	for (local i: [:#result.imc_offtab]) {
		result.imc_offtab[i] += offtab_size;
	}

	/* Find the largest gap in unicode ordinals. */
	local largestGapMin = 0;
	local largestGapMax = -1;
	local largestGapSiz = 0;
	local prevOrdPlusOne = 0;
	onebyte_uni.sort();
	onebyte_uni.append(0x10000);
	for (local ord: onebyte_uni) {
		local size = ord - prevOrdPlusOne;
		if (largestGapSiz < size) {
			largestGapMin = prevOrdPlusOne;
			largestGapMax = ord;
			largestGapSiz = size;
		}
		prevOrdPlusOne = ord + 1;
	}
	assert largestGapSiz >= #result.imc_offtab, "Largest gap is too small";
	result.imc_offidx_min = largestGapMin;
	result.imc_offidx_max = largestGapMin + #result.imc_offtab - 1;

	/* Relocate 2-byte table indices */
	for (local i: [:256]) {
		local off = result.imc_1byte[i];
		if (off >= 0x10000) {
			off = off - 0x10000;
			assert off < #result.imc_offtab;
			result.imc_1byte[i] = off + largestGapMin;
		}
	}

	return result;
}

function firstByteToStr(b: {int...}): string {
	if (#b == 1)
		return b.first.hex()[2:].zfill(2) + "h";
	return "[{}]".format({
		",".join(for (local x: b) x.hex()[2:].zfill(2) + "h")
	});
}

function printCpMbcsDatabase() {
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is MbcsCodec)
			codecs.append(codec);
	}
	codecs.sort(MbcsCodec.name);

	/* Generate extended codec data */
	local exCodecs: {ExMbcsCodec...} = List(
		for (local codec: codecs)
			createExMbcsCodec(codec));

	/* Assert that offset table values aren't too large */
	local final MAX_OFFSET = (1 << (SIZEOF__imc_offtab__elements * 8)) - 1;
	for (local exCodec: exCodecs) {
		local cMaxOffset = exCodec.imc_offtab > ...;
		assert cMaxOffset <= MAX_OFFSET;
	}

	/* Print the database control structure */
	print("struct iconv_mbcs_database {");
	for (local exCodec: exCodecs) {
		print("	struct {");
		print("		char16_t _1[256];");
		print("		char16_t _oi; /* U+", exCodec.imc_offidx_min.hex()[2:].upper().zfill(4), " */");
		print("		char16_t _ox; /* U+", exCodec.imc_offidx_max.hex()[2:].upper().zfill(4), " */");
		print("		uint16_t _ot[", (#exCodec.imc_offtab).hex(), "];");
		for (local b2_i, b2: util.enumerate(exCodec.byte2_tables)) {
			print("		/* First byte: ", firstByteToStr(b2._firstbyte), " */");
			for (local range_i, range: util.enumerate(b2.ranges)) {
				print("		byte_t "),;
				print("_", b2_i, "r", range_i, "_t,"),;
				print("_", b2_i, "r", range_i, "_cx,"),;
				print("_", b2_i, "r", range_i, "_ci,"),;
				print("_", b2_i, "r", range_i, "_s;"),;
				print(" uint16_t _", b2_i, "r", range_i),;
				switch (range.imc_type) {
				case ICONV_MBCS_BYTE2_RANGE_TYPE_LIN:
					print("_l;"),;
					break;
				case ICONV_MBCS_BYTE2_RANGE_TYPE_ARR:
					print("_a[", (#range.imc_arr).hex(), "];"),;
					break;
				case ICONV_MBCS_BYTE2_RANGE_TYPE_ARR32:
					print("_A[", (#range.imc_arr * 2).hex(), "];"),;
					break;
				case ICONV_MBCS_BYTE2_RANGE_TYPE_TAB:
					print("_T;"),;
					break;
				default: assert false;
				}
				print;
			}
			print("		byte_t _", b2_i, "_et,_", b2_i, "_ex;");
		}
		print("	} ", dbFieldName(exCodec.codec.name), ";");
	}
	print("};");

	/* Print the offset table. */
	for (local i, codec: util.enumerate(codecs))
		print("STATIC_ASSERT(CODEC_MBCS_MIN + ", i, " == ", codec.name, ");");
	print("INTERN_CONST libiconv_mbcs_offset_t const libiconv_mbcs_offsets[", #codecs, "] = {");
	for (local codec: codecs)
		print("	/* [", codec.name, " - CODEC_MBCS_MIN] = */ offsetof(struct iconv_mbcs_database, ", dbFieldName(codec.name), "),");
	print("};");

	/* Print the database contents */
	print("#undef E");
	print("#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__");
	print("#define E(a,b) a,b");
	print("#else");
	print("#define E(a,b) b,a");
	print("#endif");
	print("INTERN_CONST struct iconv_mbcs_database const libiconv_mbcs_db = {");
	for (local exCodec: exCodecs) {
		print;
		print("	/* .", dbFieldName(exCodec.codec.name), " = */ {");
		print("		{"),; /* _1 */
		printCompressed(exCodec.imc_1byte, "		 ");
		print("},");
		print("		", exCodec.imc_offidx_min, ","); /* _oi */
		print("		", exCodec.imc_offidx_max, ","); /* _ox */
		print("		{"),; /* _ot */
		printCompressed(exCodec.imc_offtab, "		 ");
		print("},");
		for (local b2_i, b2: util.enumerate(exCodec.byte2_tables)) {
			print("		/* First byte: ", firstByteToStr(b2._firstbyte), " */");
			for (local range_i, range: util.enumerate(b2.ranges)) {
				print("		"),;
//				print("._", b2_i, "r", range_i, "_t="),;
				print(range.imc_type, ","),;
//				print("._", b2_i, "r", range_i, "_cx="),;
				print(range.imc_cpmax, ","),;
//				print("._", b2_i, "r", range_i, "_ci="),;
				print(range.imc_cpmin, ","),;
//				print("._", b2_i, "r", range_i, "_s="),;
				print(range.imc_size, ","),;
				switch (range.imc_type) {
				case ICONV_MBCS_BYTE2_RANGE_TYPE_LIN:
					/* "_", b2_i, "r", range_i, "_l" */
					print(range.imc_lin, ",");
					break;
				case ICONV_MBCS_BYTE2_RANGE_TYPE_ARR: {
					print;
					/* "._", b2_i, "r", range_i, "_a" */
					print("		{"),;
					printCompressed(range.imc_arr, "		 ");
					print("},");
				}	break;
				case ICONV_MBCS_BYTE2_RANGE_TYPE_ARR32: {
					print;
					/* "._", b2_i, "r", range_i, "_A" */
					print("		{"),;
					printCompressed((for (local x: range.imc_arr)
						"E({},{})".format({ x >> 16, x & 0xffff })
					), "		 ");
					print("},");
				}	break;
				case ICONV_MBCS_BYTE2_RANGE_TYPE_TAB: {
					/* "_", b2_i, "r", range_i, "_T" */
					print(range.imc_tab.offset, ",");
				}	break;
				default: assert false;
				}
			}
			print("		/*_", b2_i, "_et*/"),;
			print(ICONV_MBCS_BYTE2_RANGE_TYPE_EOF, ","),;
//			print("._", b2_i, "_ex="),;
			print("255,");
		}
		print("	},");
	}
	print("};");
	print("#undef E");

}
